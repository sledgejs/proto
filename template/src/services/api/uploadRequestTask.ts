import axios, { AxiosProgressEvent, AxiosRequestConfig, CancelTokenSource } from 'axios';
import { action, computed, makeObservable, observable } from 'mobx';
import { isFiniteNumber } from '../../core/typeUtils';
import { Kernel } from '../../kernel/kernel';
import { AsyncResult } from '../../core/types';
import { Error } from '../../errors/error';
import { BaseTask, BaseTaskProps } from '../../tasks/baseTask';
import { ErrorCode } from '../../errors/errorCode';

type Props = BaseTaskProps & {
  url: string;
  file: File;
  data?: UploadRequestFormField[];
}

export type UploadRequestTaskProps = Props;

export type UploadRequestFormField = {
  key: string,
  value: string
}

/**
 * Simple wrapper for an upload task on a provided url.
 * Contains upload progress information.
 * Uses axios behind the scenes because it was too complicated for the people
 * writing the fetch spec to include progress information.
 */
export class UploadRequestTask
  extends BaseTask {

  constructor(kernel: Kernel, props: Props) {
    super(kernel, props);
    makeObservable(this);

    // didn't go with Object.assign to avoid confusing TS
    this.url = props.url;
    this.file = props.file;
    this.data = props.data;

    // we need to correlate 2 abort signals, one external coming from props
    // and one internal generated by axios
    this.abortSignal.addEventListener('abort', () => {
      this.cancelRequest()
    });
  }

  readonly url: string;
  readonly file: File;
  readonly data?: UploadRequestFormField[];

  private cancelToken?: CancelTokenSource;

  @observable totalBytes: number = 0;
  @observable loadedBytes: number = 0;

  @computed
  get progressRatio(): number {
    return this.loadedBytes / this.totalBytes;
  }

  protected async executor(): AsyncResult {

    const CancelToken = axios.CancelToken;
    const source = CancelToken.source();
    this.cancelToken = source;

    const { file, data, url } = this;

    const formData = new FormData();

    if (data) {
      for (let pair of data)
        formData.append(pair.key, pair.value);
    }

    formData.append('file', file);

    const config: AxiosRequestConfig = {
      cancelToken: source.token,
      onUploadProgress: this.handleUploadProgress
    };

    try {

      let resData = await axios.post(url, formData, config);
      return [true];

    } catch (err) {

      if (axios.isCancel(err))
        return [null, this.abortedError];

      return [null, new Error(ErrorCode['Api.UploadError'], { source: err })];
    }
  }

  private cancelRequest() {
    this.cancelToken?.cancel();
  }

  @action
  private handleUploadProgress = (evt: AxiosProgressEvent) => {

    if (isFiniteNumber(evt.loaded) && isFiniteNumber(evt.total)) {
      this.loadedBytes = evt.loaded;
      this.totalBytes = evt.total;
    }
  }
}